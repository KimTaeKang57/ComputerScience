### Socket 이란 무엇인가 ?
- 네트워크 상에서 돌아가는 두 개의 프로그램 간 양방향 통신의 하나의 엔드 포인트, 포트 번호에 바인딩되어 TCP 레이어에서 데이터가 전달돼야하는 어플리케이션을 식별할 수 있게 함
- 엔드 포인트 : 아이피 주소와 포트 번호의 조합. 모든 TCP 연결은 2개의 엔드 포인트로 유일하게 식별됨. 따라서 클라이언트와 서버 간 여러개의 연결이 맺어질 수 있음
IP : 전세계 컴퓨터에 부여된 고유의 식별 주소
PORT : 포트는 네트워크 상에서 통신하기 위해 호스트 내부적으로 프로세스가 할당받아야 하는 고유한 숫자이다. 한 호스트 내에서 네트워크 통신을 하고 있는 프로세스를 식별하기 위해 사용되는 값이기 때문에, 같은 호스트 내에서 서로 다른 프로세스가 같은 포트 넘버를 가질 수 없다. 즉, 같은 컴퓨터 내에서 프로그램을 식별하는 번호이다.
- 소켓은 떨어져 있는 두 호스트를 연결해주는 도구로 인터페이스 역할을 하는데, 데이터를 주고 받을 수 있는 구조체로 소켓을 통해 데이터 통로가 만들어진다.

### 소켓 통신의 흐름
<img width="642" alt="스크린샷 2022-06-15 오후 8 19 55" src="https://user-images.githubusercontent.com/83891837/173815262-d01fbabe-da58-460a-88b8-3ce317b00434.png">

* 서버 : 클라이언트 소켓의 연결 요청을 대기하고 연결 요청이 오면 클라이언트 소켓을 생성하여 통신이 가능하게 한다
1. socket() 함수로 소켓 생성
2. bind() 함수로 ip / port 번호 지정
3. listen() 함수로 클라이언트의 접근 요청에 대해 수신 대기열을 만들어 몇 개의 클라이언트를 대기 시킬지 결정
4. accept() 함수를 사용하여 클라이언트와의 연결을 기다림

* 클라이언트 : 데이터 송수신이 일어나는 곳
1. socket() 함수로 가장먼저 소켓을 염
2. connect() 함수를 이용해 통신 할 서버의 설정된 ip / port에 통신을 시도
3. 통신 시도 시 서버가 accept() 함수를 이용해 클라이언트의 socket descriptor를 반환
4. 이렇게 클라이언트와 서버가 서로 read() write()를 해 양방향 통신

# 소켓의 종류
### TCP(스트림)
- 연결 지향적 프로토콜 : 클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜
<img width="404" alt="스크린샷 2022-06-15 오후 8 30 46" src="https://user-images.githubusercontent.com/83891837/173817236-af507925-f594-43da-9361-ec41840e2d1d.png">

- 클라이언트 연결 요청(SYN 데이터 전송) -> 서버 연결 수락 -> 통신 선로 고정 -> 고정 통신 선로를 통해 순차적 전달
: 데이터를 정확하고 안정적으로 전달 가능
- 호스트 간 신뢰성 있는 데이터 전달과 흐름 제어를 함
: 패킷 전송 성공 -> ACK 신호 날림 -> if ACK가 제시간에 도착 안하면 : Timeout 발생 -> 패킷 손실 발생 패킷 재 전송

이렇게 TCP는 데이터를 송신할때마다 확인 응답을 주고받는 절차가 있어 통신의 신뢰성이 증가함. 네트워크를 사용한 통신을 할 때 TCP 통신을 많이 사용함

단점 : 데이터로 보내기 전에 반드시 연결 형성되어야함, 1:1 통신만 가능, 고정 통신 선로가 최단선이 아니면 UDP보다 상대적으로 데이터 전송속도가 느림

### UDP(데이터그램)
- 비연결 지향적 프로토콜 : 데이터를 주고받을 때 연결 절차를 거치지 않고 발신자가 일방적으로 데이터를 발신하는 방식
<img width="404" alt="스크린샷 2022-06-15 오후 8 35 39" src="https://user-images.githubusercontent.com/83891837/173818090-e607dd0e-1e3c-4620-b6c8-83ecdb872b18.png">

- 연결 과정이 없기 때문에 TCP 보다 빠른 전송은 가능하지만 데이터 전달의 신뢰성은 떨어짐
- UDP는 발신자가 데이터 패킷을 순차적으로 보내더라도 서로 다른 통신 선로를 통해 전달 가능, 먼저 보낸 패킷이 느린 선로를 통해 전송될 경우 나중에 보낸 패킷보다 늦게 도착할수 있으며 최악의 경우 잘못된 선로로 전송돼 유실될 수 있음, TCP와 다르게 UDP는 패킷 유실 / 변조가 돼도 재전송을 하지 않음

### 3 way handshake (SYN, ACK)
<img width="404" alt="스크린샷 2022-06-15 오후 8 38 00" src="https://user-images.githubusercontent.com/83891837/173818427-0a158b1c-47a1-415f-8785-004b4e41cafd.png">

- TCP 통신을 위한 네트워크 연결은 3 way handshake 라는 방식으로 연결된다. 서로의 통신을 위한 port를 확인하고 연결하기 위해 3번의 요청 / 응답 후에 연결 되는 것을 말한다. (이 과정에서 가장 많은 시간이 소요되어 UDP 방식보다 속도가 느려지는 주요 원인)

- 연결과정
1. 클라이언트에서 서버에 연결 요청을 하기위해 SYN 데이터를 보냄
2. 서버에서 해당 포트는 LISTEN 상태에서 SYN 데이터를 받고 SYN_RCV로 상태가 변경
3. 청을 정상적으로 받았다는 대답(ACK)와 Client도 포트를 열어달라는 SYN 을 같이 보냄
4. Client에서는 SYN+ACK 를 받고 ESTABLISHED로 상태를 변경하고 서버에 ACK 를 전송
5. ACK를 받은 서버는 상태가 ESTABLSHED로 변경

### 4 way handshake
<img width="594" alt="스크린샷 2022-06-15 오후 8 40 55" src="https://user-images.githubusercontent.com/83891837/173818857-1718f670-1b45-46c3-8679-e04e8537814a.png">

- TCP 통신을 위한 네트워크 연결엔 4 way handshake도 사용된다.
1. 클라이언트에서 서버와의 연결 종료를 위해 서버에 FIN 패킷을 보내고 FIN_WAIT1 상태가 됨 (반대로 서버에서 먼저 끊을 수 도 있음)
2. 서버는 클라이언트로부터 FIN을 받고 응답 패킷 ACK을 보내고, 상태는 CLOSE_WAIT가 됨
3. 서버가 통신이 끝나면, 즉 연결을 종료할 준비가 되면 클라이언트에게 FIN패킷을 보내고 LAST_WAIT 상태가 됨  
4. 클라이언트는 확인 패킷 ACK을 보내고 TIME_WAIT 상태가 됨

이런식으로 서버와 클라이언트는 안전하게 세션을 종료함
